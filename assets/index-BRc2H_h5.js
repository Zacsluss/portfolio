const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/About-CzcRFJvE.js","assets/r3f-vendor-CnF0ZzKO.js","assets/three-core-BP32A1ED.js","assets/react-vendor-HnKmhvXM.js","assets/portfolio-data-DpNwOxxL.js","assets/About-DyC7S3JC.css","assets/Skills-C1dJlNKn.js","assets/Skills-BpUDTwup.css","assets/Experience-DzGCkdV_.js","assets/Experience-CNlYdX8S.css","assets/Projects-DmFmzAKY.js","assets/Projects-CTbvnR3P.css","assets/Leadership-Dhg6wuf3.js","assets/Leadership-HGUcYtqB.css","assets/Contact-CtV7FL2c.js","assets/Contact-DAcHlcn6.css"])))=>i.map(i=>d[i]);
import{s as e,e as t,r as o,u as n,a as r,j as a,_ as s,C as i,O as l,c}from"./r3f-vendor-CnF0ZzKO.js";import{e as f,r as m,D as u,g as h,h as d,R as p,m as v}from"./three-core-BP32A1ED.js";import"./react-vendor-HnKmhvXM.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver(e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)}).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();t({StarfieldMaterial:e({time:0,speed:2},"\n    uniform float time;\n    uniform float speed;\n    attribute float size;\n    attribute float brightness;\n    attribute float colorTemp; // Star color temperature\n    attribute float twinklePhase; // Random phase for twinkling\n    varying float vBrightness;\n    varying float vDistance;\n    varying float vColorTemp;\n    varying float vTwinkle;\n\n    void main() {\n      vBrightness = brightness;\n      vColorTemp = colorTemp;\n\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n      vDistance = -mvPosition.z;\n\n      // Twinkling effect - stars shimmer over time\n      vTwinkle = 0.7 + 0.3 * sin(time * (2.0 + twinklePhase) + twinklePhase * 100.0);\n\n      // Size based on distance for depth of field\n      float depthScale = 300.0 / vDistance;\n      depthScale = clamp(depthScale, 0.1, 5.0);\n\n      gl_PointSize = size * depthScale * vTwinkle;\n      gl_Position = projectionMatrix * mvPosition;\n    }\n  ","\n    uniform float time;\n    varying float vBrightness;\n    varying float vDistance;\n    varying float vColorTemp;\n    varying float vTwinkle;\n\n    // Convert color temperature to RGB (black body radiation)\n    vec3 temperatureToColor(float temp) {\n      // temp: 0.0 = cool blue, 0.5 = white, 1.0 = red giant\n      if (temp < 0.33) {\n        // Blue-white stars (hot)\n        return mix(vec3(0.7, 0.8, 1.0), vec3(0.95, 0.95, 1.0), temp / 0.33);\n      } else if (temp < 0.66) {\n        // White-yellow stars (medium)\n        return mix(vec3(0.95, 0.95, 1.0), vec3(1.0, 0.95, 0.8), (temp - 0.33) / 0.33);\n      } else {\n        // Yellow-red stars (cool)\n        return mix(vec3(1.0, 0.95, 0.8), vec3(1.0, 0.7, 0.5), (temp - 0.66) / 0.34);\n      }\n    }\n\n    void main() {\n      vec2 center = gl_PointCoord - vec2(0.5);\n      float dist = length(center);\n\n      if (dist > 0.5) discard;\n\n      // Bokeh hexagon shape for distant stars\n      float bokeh = 1.0;\n      if (vDistance > 100.0) {\n        float angle = atan(center.y, center.x);\n        float hexDist = cos(floor(0.5 + angle / 1.047) * 1.047 - angle) * dist;\n        bokeh = smoothstep(0.5, 0.4, hexDist);\n      }\n\n      // Soft glow falloff with enhanced bloom\n      float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n      alpha = pow(alpha, 1.2) * bokeh;\n\n      // Apply twinkling to brightness\n      alpha *= vBrightness * vTwinkle;\n\n      // Realistic star color based on temperature\n      vec3 color = temperatureToColor(vColorTemp);\n\n      // Chromatic aberration for bright close stars (lens effect)\n      if (vDistance < 80.0 && vBrightness > 0.7) {\n        float aberration = 0.02;\n        vec2 redOffset = center * (1.0 + aberration);\n        vec2 blueOffset = center * (1.0 - aberration);\n\n        float redDist = length(redOffset);\n        float blueDist = length(blueOffset);\n\n        vec3 aberratedColor;\n        aberratedColor.r = color.r * (1.0 - smoothstep(0.0, 0.5, redDist));\n        aberratedColor.g = color.g * (1.0 - smoothstep(0.0, 0.5, dist));\n        aberratedColor.b = color.b * (1.0 - smoothstep(0.0, 0.5, blueDist));\n\n        color = mix(color, aberratedColor, 0.3);\n      }\n\n      // Distance-based color shift (atmospheric perspective)\n      if (vDistance > 150.0) {\n        color = mix(color, vec3(0.8, 0.85, 1.0), 0.2);\n      }\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ")});function x({count:e=1e4,speed:t=2}){const s=o.useRef(),i=o.useRef(),l=o.useRef(),c=o.useRef(),{camera:f}=n(),[d,p,v,x,g]=o.useMemo(()=>{const t=new Float32Array(3*e),o=new Float32Array(e),n=new Float32Array(e),r=new Float32Array(e),a=new Float32Array(e);for(let s=0;s<e;s++){const e=3*s,i=100+200*Math.pow(Math.random(),.5),l=Math.random()*Math.PI*2,c=Math.acos(2*Math.random()-1);t[e]=f.position.x+i*Math.sin(c)*Math.cos(l),t[e+1]=f.position.y+i*Math.sin(c)*Math.sin(l),t[e+2]=f.position.z+i*Math.cos(c);const m=Math.random();o[s]=m<.7?1+1*Math.random():m<.95?2+2*Math.random():4+3*Math.random(),n[s]=.3+.7*Math.random();const u=Math.random();r[s]=u<.15?.3*Math.random():u<.8?.3+.36*Math.random():.66+.34*Math.random(),a[s]=Math.random()*Math.PI*2}return[t,o,n,r,a]},[e,f.position.x,f.position.y,f.position.z]),[y]=o.useMemo(()=>{const e=new Float32Array(1200),t=new Float32Array(200);for(let o=0;o<200;o++){const n=6*o,r=80*Math.random(),a=Math.random()*Math.PI*2,s=Math.cos(a)*r,i=80*(Math.random()-.5),l=-100*Math.random();e[n]=s,e[n+1]=i,e[n+2]=l;const c=5+10*Math.random();e[n+3]=s,e[n+4]=i,e[n+5]=l-c,t[o]=.2+.5*Math.random()}return[e,t]},[]);return r(o=>{if(!s.current)return;const n=new h;f.getWorldDirection(n);const r=n.clone().multiplyScalar(-t),a=s.current.geometry.attributes.position.array;for(let t=0;t<e;t++){const e=3*t;a[e]+=r.x,a[e+1]+=r.y,a[e+2]+=r.z;const o=a[e]-f.position.x,s=a[e+1]-f.position.y,i=a[e+2]-f.position.z,l=o*o+s*s+i*i,c=o*n.x+s*n.y+i*n.z;if(l>1e5||c<-50){const t=200+100*Math.random(),o=Math.random()*Math.PI*2,r=.0035,s=.75*Math.PI,i=Math.cos(s),l=Math.cos(r),c=i+Math.random()*(l-i),m=Math.acos(c),u=new h(0,1,0),d=(new h).crossVectors(n,u).normalize(),p=(new h).crossVectors(d,n).normalize(),v=t*Math.tan(m),x=v*Math.cos(o),g=v*Math.sin(o);a[e]=f.position.x+n.x*t+d.x*x+p.x*g,a[e+1]=f.position.y+n.y*t+d.y*x+p.y*g,a[e+2]=f.position.z+n.z*t+d.z*x+p.z*g}}if(s.current.geometry.attributes.position.needsUpdate=!0,i.current){const e=i.current.geometry.attributes.position.array,o=200,a=1.5*t;for(let s=0;s<o;s++){const o=6*s;e[o]+=r.x*(a/t),e[o+1]+=r.y*(a/t),e[o+2]+=r.z*(a/t),e[o+3]+=r.x*(a/t),e[o+4]+=r.y*(a/t),e[o+5]+=r.z*(a/t);const i=e[o]-f.position.x,l=e[o+1]-f.position.y,c=e[o+2]-f.position.z,m=i*i+l*l+c*c,u=i*n.x+l*n.y+c*n.z;if(m>5e4||u<-30){const t=120+30*Math.random(),r=Math.random()*Math.PI*2,a=60*Math.random(),s=new h(0,1,0),i=(new h).crossVectors(n,s).normalize(),l=(new h).crossVectors(i,n).normalize(),c=f.position.x+n.x*t+i.x*Math.cos(r)*a+l.x*Math.sin(r)*a,m=f.position.y+n.y*t+i.y*Math.cos(r)*a+l.y*Math.sin(r)*a,u=f.position.z+n.z*t+i.z*Math.cos(r)*a+l.z*Math.sin(r)*a;e[o]=c,e[o+1]=m,e[o+2]=u;const d=5+10*Math.random();e[o+3]=c+n.x*d,e[o+4]=m+n.y*d,e[o+5]=u+n.z*d}}i.current.geometry.attributes.position.needsUpdate=!0}l.current&&(l.current.time=o.clock.elapsedTime),c.current&&(c.current.time=o.clock.elapsedTime)}),a.jsxs("group",{children:[a.jsxs("points",{ref:s,children:[a.jsxs("bufferGeometry",{children:[a.jsx("bufferAttribute",{attach:"attributes-position",count:e,array:d,itemSize:3}),a.jsx("bufferAttribute",{attach:"attributes-size",count:e,array:p,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-brightness",count:e,array:v,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-colorTemp",count:e,array:x,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-twinklePhase",count:e,array:g,itemSize:1})]}),a.jsx("starfieldMaterial",{ref:l,transparent:!0,depthWrite:!1,blending:m,speed:t})]}),a.jsxs("lineSegments",{ref:i,children:[a.jsx("bufferGeometry",{children:a.jsx("bufferAttribute",{attach:"attributes-position",count:400,array:y,itemSize:3})}),a.jsx("lineBasicMaterial",{color:"#ffffff",transparent:!0,opacity:.3,blending:m,depthWrite:!1})]}),a.jsxs("mesh",{position:[0,0,-250],scale:[300,300,1],children:[a.jsx("planeGeometry",{args:[1,1,1,1]}),a.jsx("nebulaMaterial",{ref:c,transparent:!0,depthWrite:!1,blending:m,side:u})]})]})}t({NebulaMaterial:e({time:0,color1:new f(.05,0,.15),color2:new f(0,.1,.2),color3:new f(.15,0,.1)},"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ","\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 color3;\n    varying vec2 vUv;\n\n    // Simple noise function\n    float noise(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n    }\n\n    float smoothNoise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n\n      float a = noise(i);\n      float b = noise(i + vec2(1.0, 0.0));\n      float c = noise(i + vec2(0.0, 1.0));\n      float d = noise(i + vec2(1.0, 1.0));\n\n      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    }\n\n    float fractalNoise(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      for (int i = 0; i < 4; i++) {\n        value += smoothNoise(p) * amplitude;\n        p *= 2.0;\n        amplitude *= 0.5;\n      }\n      return value;\n    }\n\n    void main() {\n      vec2 uv = vUv * 2.0 - 1.0;\n\n      // Multiple layers of noise moving at different speeds\n      float noise1 = fractalNoise(vUv * 3.0 + time * 0.02);\n      float noise2 = fractalNoise(vUv * 5.0 - time * 0.03);\n      float noise3 = fractalNoise(vUv * 7.0 + time * 0.01);\n\n      // Combine noise layers\n      float combinedNoise = (noise1 + noise2 + noise3) / 3.0;\n\n      // Create color variation\n      vec3 nebulaColor = mix(color1, color2, noise1);\n      nebulaColor = mix(nebulaColor, color3, noise2);\n\n      // Radial falloff from center for depth\n      float distFromCenter = length(uv);\n      float radialMask = 1.0 - smoothstep(0.0, 1.5, distFromCenter);\n\n      float alpha = combinedNoise * 0.15 * radialMask;\n\n      gl_FragColor = vec4(nebulaColor, alpha);\n    }\n  ")});function g({text:e="HELLO",morphToText:t=null,scrollProgress:s=0,size:i=100,konamiActivated:l=!1,onMorphComplete:c=null}){const f=o.useRef(),u=o.useRef(),{viewport:x,mouse:g}=n(),y=o.useRef(Date.now()),b=o.useRef(!1),w=o.useRef(e),M=o.useRef(0),P=o.useRef(0),j=o.useRef(!1),A=o.useRef(new d(0,0)),z=o.useRef(0),[S,E]=o.useState(!1);o.useEffect(()=>{document.fonts.load("bold 100px Orbitron").then(()=>{E(!0)}).catch(()=>{setTimeout(()=>E(!0),1e3)})},[]);const C=(e,t,o,n)=>{o.fillStyle="#000000",o.fillRect(0,0,t.width,t.height),o.fillStyle="#ffffff",o.font=`bold ${n}px Orbitron, Arial`,o.textAlign="center",o.textBaseline="middle",o.fillText(e,t.width/2,t.height/2);const r=o.getImageData(0,0,t.width,t.height).data;let a=t.width,s=0,i=t.height,l=0;for(let u=0;u<t.width;u++)for(let e=0;e<t.height;e++){r[4*(e*t.width+u)]>128&&(a=Math.min(a,u),s=Math.max(s,u),i=Math.min(i,e),l=Math.max(l,e))}const c=(a+s)/2,f=(i+l)/2,m=[];for(let u=0;u<t.width;u+=1)for(let e=0;e<t.height;e+=1){if(r[4*(e*t.width+u)]>128){const t=.12,o=(u-c)*t,n=-(e-f)*t,r=2*(Math.random()-.5);m.push(o,n,r)}}return m},{positions:k,targetPositions:T,scrollTargetPositions:N,randomness:D,speeds:F,offsets:R,colorSeeds:_,particleCount:L}=o.useMemo(()=>{if(!S)return{positions:new Float32Array(0),targetPositions:new Float32Array(0),scrollTargetPositions:new Float32Array(0),randomness:new Float32Array(0),speeds:new Float32Array(0),offsets:new Float32Array(0),colorSeeds:new Float32Array(0),particleCount:0};const o=document.createElement("canvas"),n=o.getContext("2d");o.width=1024,o.height=256;const r=C(e,o,n,i),a=t?C(t,o,n,i):[...r],s=[],l=[],c=[],f=[],m=[],u=[],h=[];for(let e=0;e<r.length;e+=3){l.push(r[e],r[e+1],r[e+2]),a.length>e+2?c.push(a[e],a[e+1],a[e+2]):c.push(30*(Math.random()-.5),30*(Math.random()-.5),10*(Math.random()-.5));const t=Math.random()*Math.PI*2,o=20+30*Math.random(),n=Math.cos(t)*o,i=Math.sin(t)*o,d=20*(Math.random()-.5);s.push(n,i,d),f.push(Math.random()),m.push(.5+2*Math.random()),u.push(Math.random()*Math.PI*2),h.push(Math.random())}return{positions:new Float32Array(s),targetPositions:new Float32Array(l),scrollTargetPositions:new Float32Array(c),randomness:new Float32Array(f),speeds:new Float32Array(m),offsets:new Float32Array(u),colorSeeds:new Float32Array(h),particleCount:s.length/3}},[e,t,i,S]);return o.useEffect(()=>{if(S){if(w.current!==e){b.current=!1,y.current=Date.now()+500,w.current=e;const t=setTimeout(()=>{b.current=!0,y.current=Date.now()},500);return()=>clearTimeout(t)}{const e=setTimeout(()=>{b.current=!0,y.current=Date.now()},1e3);return()=>clearTimeout(e)}}},[e,S]),o.useEffect(()=>{l&&(M.current=Date.now(),setTimeout(()=>{P.current=Date.now()},2e3))},[l]),r(e=>{if(u.current){if(u.current.time=e.clock.elapsedTime,b.current){const e=(Date.now()-y.current)/3e3;u.current.morphProgress=Math.max(0,Math.min(e,1)),u.current.morphProgress>=1&&!j.current&&c&&(j.current=!0,c())}else u.current.morphProgress=0;if(u.current.scrollMorphProgress=s,M.current>0){const e=(Date.now()-M.current)/2e3;u.current.blackHoleEffect=e<1?e:e<2?2-e:0}else u.current.blackHoleEffect=0;if(P.current>0){const e=(Date.now()-P.current)/3e3;e<.5?u.current.explosionEffect=2*e:e<1?u.current.explosionEffect=2-2*e:(u.current.explosionEffect=0,e>1.2&&(M.current=0,P.current=0))}else u.current.explosionEffect=0;const t=new p;t.setFromCamera(g,e.camera);const o=new v(new h(0,0,1),0),n=new h;let r,a;if(t.ray.intersectPlane(o,n),f.current&&n){const e=f.current.worldToLocal(n.clone());r=e.x,a=e.y}else r=g.x*(x.width/2),a=g.y*(x.height/2);const i=r-A.current.x,l=a-A.current.y,m=Math.sqrt(i*i+l*l);z.current=.9*z.current+.1*m,u.current.mousePosition.x=r,u.current.mousePosition.y=a,u.current.mouseVelocity=Math.min(z.current,5),A.current.set(r,a)}f.current&&(f.current.position.set(0,0,0),u.current&&u.current.morphProgress>.5&&(f.current.rotation.y=.05*Math.sin(.2*e.clock.elapsedTime),f.current.rotation.x=.02*Math.cos(.3*e.clock.elapsedTime)))}),0===L?null:a.jsxs("points",{ref:f,children:[a.jsxs("bufferGeometry",{children:[a.jsx("bufferAttribute",{attach:"attributes-position",count:L,array:k,itemSize:3}),a.jsx("bufferAttribute",{attach:"attributes-targetPosition",count:L,array:T,itemSize:3}),a.jsx("bufferAttribute",{attach:"attributes-scrollTargetPosition",count:L,array:N,itemSize:3}),a.jsx("bufferAttribute",{attach:"attributes-randomness",count:L,array:D,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-speed",count:L,array:F,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-offset",count:L,array:R,itemSize:1}),a.jsx("bufferAttribute",{attach:"attributes-colorSeed",count:L,array:_,itemSize:1})]}),a.jsx("fluidParticleMaterial",{ref:u,transparent:!0,depthWrite:!1,blending:m})]},e)}function y(){const e=o.useRef(null);return o.useEffect(()=>{let t=-9999,o=-9999,n=-9999,r=-9999;const a=e=>{t=e.clientX,o=e.clientY},s=()=>{n+=.15*(t-n),r+=.15*(o-r),e.current&&(e.current.style.left=`${n}px`,e.current.style.top=`${r}px`),requestAnimationFrame(s)};return window.addEventListener("mousemove",a),s(),()=>{window.removeEventListener("mousemove",a)}},[]),a.jsx("div",{ref:e,className:"simple-cursor"})}t({FluidParticleMaterial:e({time:0,morphProgress:0,scrollMorphProgress:0,mousePosition:new d(0,0),mouseVelocity:0,blackHoleEffect:0,explosionEffect:0,colorA:new f("#00ff88"),colorB:new f("#0088ff"),colorC:new f("#ff006e"),colorD:new f("#ffaa00"),colorE:new f("#aa00ff")},"\n    uniform float time;\n    uniform float morphProgress;\n    uniform float scrollMorphProgress;\n    uniform vec2 mousePosition;\n    uniform float mouseVelocity;\n    uniform float blackHoleEffect;\n    uniform float explosionEffect;\n\n    attribute vec3 targetPosition;\n    attribute vec3 scrollTargetPosition;  // Second text for scroll morph\n    attribute float randomness;\n    attribute float speed;\n    attribute float offset;\n    attribute float colorSeed;\n    \n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    void main() {\n      // Fluid physics simulation\n      float t = morphProgress;\n      vec3 pos = position;\n      \n      // Turbulence ONLY when forming (when t < 1.0), then completely stable\n      float turbulence = 0.0;\n      if (t < 1.0) {\n        turbulence = sin(time * 1.0 + offset * 6.28) * (1.0 - t) * (1.0 - t) * 1.5;\n        pos.x += sin(time * 0.5 + offset * 3.14) * turbulence;\n        pos.y += cos(time * 0.3 + offset * 2.0) * turbulence;\n        pos.z += sin(time * 0.7 + offset * 4.0) * turbulence * 0.5;\n      }\n      \n      // Morph to target position with elastic easing\n      float elasticT = t < 0.5\n        ? 4.0 * t * t * t\n        : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;\n\n      // First morph: random → name\n      vec3 baseTarget = mix(pos, targetPosition, elasticT);\n\n      // Second morph: name → tagline (scroll-based)\n      vec3 morphedPos = mix(baseTarget, scrollTargetPosition, scrollMorphProgress);\n      \n      // Black hole effect\n      if (blackHoleEffect > 0.0) {\n        vec3 blackHoleCenter = vec3(0.0, 0.0, 0.0);\n        vec3 toCenter = blackHoleCenter - morphedPos;\n        float distance = length(toCenter);\n        \n        // Spiral into black hole\n        float pullStrength = blackHoleEffect * (1.0 - smoothstep(0.0, 30.0, distance));\n        morphedPos += toCenter * pullStrength;\n        \n        // Add rotation for spiral effect\n        float angle = blackHoleEffect * 10.0 + distance * 0.5;\n        float cosAngle = cos(angle);\n        float sinAngle = sin(angle);\n        float x = morphedPos.x;\n        float z = morphedPos.z;\n        morphedPos.x = x * cosAngle - z * sinAngle;\n        morphedPos.z = x * sinAngle + z * cosAngle;\n      }\n      \n      // Supernova explosion effect with smooth transition\n      if (explosionEffect > 0.0) {\n        vec3 explosionCenter = vec3(0.0, 0.0, 0.0);\n        vec3 fromCenter = morphedPos - explosionCenter;\n        \n        // Smoother explosion curve\n        float smoothExplosion = smoothstep(0.0, 1.0, explosionEffect);\n        float explosionForce = smoothExplosion * 30.0 * (1.0 - smoothExplosion * 0.5);\n        morphedPos += normalize(fromCenter) * explosionForce;\n        \n        // Reduced randomness for smoother motion\n        morphedPos.x += sin(offset * 10.0) * smoothExplosion * 2.0;\n        morphedPos.y += cos(offset * 7.0) * smoothExplosion * 2.0;\n        morphedPos.z += sin(offset * 13.0) * smoothExplosion * 1.0;\n      }\n      \n      // Magnetic attraction to mouse (gentle, playful)\n      vec2 toMouse = mousePosition - vec2(morphedPos.x, morphedPos.y);\n      float mouseDistance = length(toMouse);\n      float attractionRadius = 6.0; // Sweet spot radius\n\n      if (mouseDistance < attractionRadius && mouseDistance > 0.1) {\n        // Gentle pull toward mouse, stronger when closer\n        float attractionStrength = (1.0 - mouseDistance / attractionRadius) * 0.8; // More noticeable pull\n\n        // TRAIL EFFECT - When mouse moves fast, add extra drag/momentum\n        // Increased multiplier from 0.5 to 2.0 for more visible trail\n        float trailEffect = mouseVelocity * 2.0; // Velocity from mouse speed\n        attractionStrength += trailEffect * (1.0 - mouseDistance / attractionRadius);\n\n        morphedPos.xy += normalize(toMouse) * attractionStrength * t; // Only when formed\n      }\n\n      // DEPTH/PARALLAX - Particles at different z-depths move differently with mouse\n      // Closer particles (negative z) move more, creating depth illusion\n      float depthFactor = (morphedPos.z + 1.0) * 0.5; // Normalize z to 0-1\n      vec2 parallaxOffset = mousePosition * 0.05 * (1.0 - depthFactor) * t;\n      morphedPos.xy += parallaxOffset;\n      \n      // DISABLE pulsing entirely for maximum stability\n      // float pulse = sin(time * 2.0 + offset * 10.0) * 0.008 * t;\n      // morphedPos *= 1.0 + pulse;\n      float pulse = 0.0;  // No pulsing at all\n\n      // QUANTUM FIELD EFFECT - Fluid hive mind oscillation when fully formed\n      if (t >= 1.0) {\n        // Slower, larger range for organic hive mind effect\n        float quantumFreq = time * 15.0 + offset * 50.0;  // Slower frequency\n        float quantumJitter = 0.12; // Larger range for fluid movement\n        morphedPos.x += sin(quantumFreq) * quantumJitter * randomness;\n        morphedPos.y += cos(quantumFreq * 1.3) * quantumJitter * randomness;\n        morphedPos.z += sin(quantumFreq * 0.7) * quantumJitter * randomness * 0.5;\n      }\n\n      // Set final position\n      vec4 mvPosition = modelViewMatrix * vec4(morphedPos, 1.0);\n      gl_Position = projectionMatrix * mvPosition;\n      \n      // Dynamic point size based on depth and morph state\n      float sizeBase = 3.0;\n      float depthSize = sizeBase * (300.0 / -mvPosition.z);\n      float morphSize = mix(2.0, depthSize, t);\n      \n      // Slightly increase size during effects (was 3.0, now 0.5)\n      float effectSize = 1.0 + max(blackHoleEffect, explosionEffect) * 0.5;\n      gl_PointSize = morphSize * (1.0 + pulse * 0.2) * effectSize;\n      \n      // Enhanced colors during effects\n      float effectBoost = max(blackHoleEffect, explosionEffect);\n      \n      // Gradient sweep across the text horizontally\n      float normalizedX = (targetPosition.x + 15.0) / 30.0;\n      float gradientPosition = normalizedX + time * 0.2 + effectBoost * 5.0; // Speed up during effects\n      \n      // Create smooth rainbow gradient across letters\n      vec3 color1 = vec3(0.0, 1.0, 0.53); // cyan\n      vec3 color2 = vec3(0.0, 0.53, 1.0); // blue\n      vec3 color3 = vec3(1.0, 0.0, 0.43); // magenta\n      vec3 color4 = vec3(1.0, 0.67, 0.0); // orange\n      vec3 color5 = vec3(0.67, 0.0, 1.0); // purple\n      \n      // Smooth gradient based on X position\n      float colorPhase = mod(gradientPosition * 2.0, 5.0);\n      \n      if (colorPhase < 1.0) {\n        vColor = mix(color1, color2, colorPhase);\n      } else if (colorPhase < 2.0) {\n        vColor = mix(color2, color3, colorPhase - 1.0);\n      } else if (colorPhase < 3.0) {\n        vColor = mix(color3, color4, colorPhase - 2.0);\n      } else if (colorPhase < 4.0) {\n        vColor = mix(color4, color5, colorPhase - 3.0);\n      } else {\n        vColor = mix(color5, color1, colorPhase - 4.0);\n      }\n      \n      // Subtle shimmer effect, enhanced during effects\n      vColor += vec3(0.1) * sin(time * 8.0 + normalizedX * 10.0) * t;\n      \n      // Make colors slightly more vibrant during effects\n      if (effectBoost > 0.0) {\n        vColor = mix(vColor, vec3(1.0, 0.5, 0.0), effectBoost * 0.2); // Subtle golden tint\n        vColor *= 1.0 + effectBoost * 0.3; // Much less brightness boost\n      }\n      \n      // Alpha based on morph progress - HIDE completely until morph starts\n      // When t < 0.05, alpha = 0 (invisible)\n      // When t >= 0.05, fade in smoothly\n      float fadeIn = smoothstep(0.0, 0.15, t);\n      vAlpha = mix(0.0, 0.3, fadeIn) * (0.8 + pulse * 0.1);\n      vAlpha = mix(vAlpha, 0.4, effectBoost * 0.5); // Much less brightness during effects\n    }\n  ","\n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    void main() {\n      // Simple circular particle shape (no rays)\n      vec2 center = gl_PointCoord - vec2(0.5);\n      float dist = length(center);\n      \n      // No sparkle rays for cleaner look\n      float rays = 1.0;\n      \n      // Much sharper, smaller particles\n      float core = 1.0 - smoothstep(0.0, 0.2, dist);\n      float innerGlow = 1.0 - smoothstep(0.2, 0.4, dist);\n      \n      float alpha = core * 0.6 + innerGlow * 0.2;\n      alpha *= vAlpha;\n      \n      if (alpha < 0.01) discard;\n      \n      // Much less brightness and glow\n      vec3 finalColor = vColor;\n      finalColor = mix(finalColor, vec3(1.0), core * 0.1); // Minimal white\n      finalColor *= 1.0 + core * 0.2; // Very reduced brightness\n      \n      gl_FragColor = vec4(finalColor, alpha);\n    }\n  ")});const b=["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];const w=o.lazy(()=>s(()=>import("./About-CzcRFJvE.js"),__vite__mapDeps([0,1,2,3,4,5])).then(e=>({default:e.About}))),M=o.lazy(()=>s(()=>import("./Skills-C1dJlNKn.js"),__vite__mapDeps([6,1,2,3,4,7])).then(e=>({default:e.Skills}))),P=o.lazy(()=>s(()=>import("./Experience-DzGCkdV_.js"),__vite__mapDeps([8,1,2,3,4,9])).then(e=>({default:e.Experience}))),j=o.lazy(()=>s(()=>import("./Projects-DmFmzAKY.js"),__vite__mapDeps([10,1,2,3,4,11])).then(e=>({default:e.Projects}))),A=o.lazy(()=>s(()=>import("./Leadership-Dhg6wuf3.js"),__vite__mapDeps([12,1,2,3,4,13])).then(e=>({default:e.Leadership}))),z=o.lazy(()=>s(()=>import("./Contact-CtV7FL2c.js"),__vite__mapDeps([14,1,2,3,4,15])).then(e=>({default:e.Contact})));function S(){const{size:e,mouse:t}=n();return o.useEffect(()=>{const o=o=>{t.x=o.clientX/e.width*2-1,t.y=-o.clientY/e.height*2+1};return document.addEventListener("mousemove",o),()=>document.removeEventListener("mousemove",o)},[e,t]),null}function E(){const[e,t]=o.useState("Zachary Sluss"),[n,r]=o.useState(!1),[s,c]=o.useState(!1),[f,m]=o.useState(!0),u=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent);o.useEffect(()=>{const e=()=>{window.scrollY>100?m(!1):m(!0)};return window.addEventListener("scroll",e),()=>window.removeEventListener("scroll",e)},[]),o.useEffect(()=>{const e=setTimeout(()=>{document.body.style.height="auto",window.scrollTo(0,1),window.scrollTo(0,0)},100);return()=>clearTimeout(e)},[]);!function(e){const[t,n]=o.useState([]);o.useEffect(()=>{const o=o=>{const r=1===o.key.length?o.key.toLowerCase():o.key,a=[...t,r].slice(-10);n(a),JSON.stringify(a)===JSON.stringify(b)&&(e(),n([]))};return window.addEventListener("keydown",o),()=>window.removeEventListener("keydown",o)},[t,e])}(()=>{c(!0),setTimeout(()=>c(!1),5e3)});return a.jsxs(a.Fragment,{children:[a.jsx(y,{}),a.jsxs(i,{className:"canvas",camera:{position:[0,0,20],fov:85},gl:{powerPreference:"high-performance",antialias:!1,stencil:!1,depth:!0,alpha:!1,pixelRatio:Math.min(window.devicePixelRatio,2)},onWheel:e=>{window.scrollBy({top:e.deltaY,behavior:"auto"})},children:[a.jsx("color",{attach:"background",args:["#000000"]}),a.jsx("fog",{attach:"fog",args:["#000000",30,150]}),a.jsx("ambientLight",{intensity:.02,color:"#1a1a2e"}),a.jsx("pointLight",{position:[50,50,50],intensity:.1,color:"#4a5f8f"}),a.jsx("pointLight",{position:[-50,-50,-50],intensity:.08,color:"#2d3561"}),a.jsx(l,{enableZoom:!1,enablePan:!1,enableRotate:!0,autoRotate:!1,enableDamping:!0,dampingFactor:.05,rotateSpeed:.5,target:[0,5,0]}),a.jsx(S,{}),a.jsxs(o.Suspense,{fallback:null,children:[a.jsx(x,{count:u?1e4:3e4,speed:2}),e&&a.jsx("group",{position:[0,5,0],children:a.jsx(g,{text:e.toUpperCase(),size:50,konamiActivated:s,onMorphComplete:()=>{r(!0)}},e)})]})]}),a.jsxs("div",{className:`scroll-indicator ${n&&f?"fade-in-1":""} ${f?"":"hide-scroll"}`,children:[a.jsx("div",{className:"mouse-icon",children:a.jsx("div",{className:"mouse-wheel"})}),a.jsx("p",{className:"scroll-text",children:"Scroll to explore"})]}),a.jsxs("div",{className:"top-right-overlay "+(n?"fade-in-1":""),children:[a.jsxs("div",{className:"portfolio-header",children:[a.jsx("h1",{className:"portfolio-title",children:"Zachary Sluss"}),a.jsx("p",{className:"portfolio-subtitle",children:"Portfolio"})]}),a.jsxs("div",{className:"user-instructions",children:[a.jsx("p",{className:"instruction-item",children:"→ Drag to rotate view"}),a.jsx("p",{className:"instruction-item",children:"→ Scroll to explore content"}),a.jsx("p",{className:"instruction-item",children:"→ Hover over particles"})]}),a.jsxs("div",{className:"name-input-container",children:[a.jsx("input",{type:"text",className:"name-input",placeholder:"Enter your name",value:e,onChange:e=>t(e.target.value),onKeyDown:e=>{"Enter"===e.key&&e.target.blur()},maxLength:20}),a.jsx("p",{className:"input-hint",children:"Type your name to see it form in particles"})]}),a.jsx("p",{className:"hint easter-egg-hint",children:"Secret Code: ↑↑↓↓←→←→BA"})]}),a.jsx("nav",{className:"sticky-nav "+(n?"fade-in-1":""),children:a.jsxs("div",{className:"nav-container",children:[a.jsx("a",{href:"#about",className:"nav-link",children:"About"}),a.jsx("a",{href:"#skills",className:"nav-link",children:"Skills"}),a.jsx("a",{href:"#experience",className:"nav-link",children:"Experience"}),a.jsx("a",{href:"#projects",className:"nav-link",children:"Projects"}),a.jsx("a",{href:"#leadership",className:"nav-link",children:"Leadership & Passions"}),a.jsx("a",{href:"#contact",className:"nav-link",children:"Contact"})]})}),a.jsx("div",{className:"main-content",children:a.jsxs(o.Suspense,{fallback:a.jsx("div",{className:"section-loading",children:"Loading..."}),children:[a.jsx("div",{id:"about",className:"content-section "+(n?"fade-in-2":""),children:a.jsx(w,{})}),a.jsx("div",{id:"skills",className:"content-section "+(n?"fade-in-3":""),children:a.jsx(M,{})}),a.jsx("div",{id:"experience",className:"content-section "+(n?"fade-in-4":""),children:a.jsx(P,{})}),a.jsx("div",{id:"projects",className:"content-section "+(n?"fade-in-5":""),children:a.jsx(j,{})}),a.jsx("div",{id:"leadership",className:"content-section "+(n?"fade-in-6":""),children:a.jsx(A,{})}),a.jsx("div",{id:"contact",className:"content-section "+(n?"fade-in-7":""),children:a.jsx(z,{})})]})})]})}c.createRoot(document.getElementById("root")).render(a.jsx(o.StrictMode,{children:a.jsx(E,{})}));
