const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/About-CtqTP-Ru.js","assets/r3f-vendor-CnF0ZzKO.js","assets/three-core-BP32A1ED.js","assets/react-vendor-HnKmhvXM.js","assets/portfolio-data-D39GSO_x.js","assets/About-_k1jxbLN.css","assets/Skills-8PqVBMM8.js","assets/Skills-WE3rV8C1.css","assets/Experience-DGiQlRGT.js","assets/Experience-0cV5jWO6.css","assets/Leadership-BX-IiNr-.js","assets/Leadership-DlIdMRtu.css","assets/Contact-Bb81T8oE.js","assets/Contact-CYJ1PEj0.css"])))=>i.map(i=>d[i]);
var e=Object.defineProperty,t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,r=(t,n,o)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[n]=o,a=(e,a)=>{for(var i in a||(a={}))n.call(a,i)&&r(e,i,a[i]);if(t)for(var i of t(a))o.call(a,i)&&r(e,i,a[i]);return e};import{s as i,e as s,r as l,u as c,a as f,j as m,_ as u,C as h,O as d,c as p}from"./r3f-vendor-CnF0ZzKO.js";import{g as v}from"./react-vendor-HnKmhvXM.js";import{e as g,r as x,D as y,g as b,h as w,R as P,m as E}from"./three-core-BP32A1ED.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver(e=>{for(const n of e)if("childList"===n.type)for(const e of n.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)}).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();var M,A,T,S,j,C={exports:{}};function N(){if(A)return M;A=1;return M="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"}function _(){if(S)return T;S=1;var e=N();function t(){}function n(){}return n.resetWarningCache=t,T=function(){function o(t,n,o,r,a,i){if(i!==e){var s=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw s.name="Invariant Violation",s}}function r(){return o}o.isRequired=o;var a={array:o,bigint:o,bool:o,func:o,number:o,object:o,string:o,symbol:o,any:o,arrayOf:r,element:o,elementType:o,instanceOf:r,node:o,objectOf:r,oneOf:r,oneOfType:r,shape:r,exact:r,checkPropTypes:n,resetWarningCache:t};return a.PropTypes=a,a}}function k(){return j||(j=1,C.exports=_()()),C.exports}const z=v(k());s({StarfieldMaterial:i({time:0,speed:2},"\n    uniform float time;\n    uniform float speed;\n    attribute float size;\n    attribute float brightness;\n    attribute float colorTemp; // Star color temperature\n    attribute float twinklePhase; // Random phase for twinkling\n    varying float vBrightness;\n    varying float vDistance;\n    varying float vColorTemp;\n    varying float vTwinkle;\n\n    void main() {\n      vBrightness = brightness;\n      vColorTemp = colorTemp;\n\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n      vDistance = -mvPosition.z;\n\n      // Twinkling effect - stars shimmer over time\n      vTwinkle = 0.7 + 0.3 * sin(time * (2.0 + twinklePhase) + twinklePhase * 100.0);\n\n      // Size based on distance for depth of field\n      float depthScale = 300.0 / vDistance;\n      depthScale = clamp(depthScale, 0.1, 5.0);\n\n      gl_PointSize = size * depthScale * vTwinkle;\n      gl_Position = projectionMatrix * mvPosition;\n    }\n  ","\n    uniform float time;\n    varying float vBrightness;\n    varying float vDistance;\n    varying float vColorTemp;\n    varying float vTwinkle;\n\n    // Convert color temperature to RGB (black body radiation)\n    vec3 temperatureToColor(float temp) {\n      // temp: 0.0 = cool blue, 0.5 = white, 1.0 = red giant\n      if (temp < 0.33) {\n        // Blue-white stars (hot)\n        return mix(vec3(0.7, 0.8, 1.0), vec3(0.95, 0.95, 1.0), temp / 0.33);\n      } else if (temp < 0.66) {\n        // White-yellow stars (medium)\n        return mix(vec3(0.95, 0.95, 1.0), vec3(1.0, 0.95, 0.8), (temp - 0.33) / 0.33);\n      } else {\n        // Yellow-red stars (cool)\n        return mix(vec3(1.0, 0.95, 0.8), vec3(1.0, 0.7, 0.5), (temp - 0.66) / 0.34);\n      }\n    }\n\n    void main() {\n      vec2 center = gl_PointCoord - vec2(0.5);\n      float dist = length(center);\n\n      if (dist > 0.5) discard;\n\n      // Bokeh hexagon shape for distant stars\n      float bokeh = 1.0;\n      if (vDistance > 100.0) {\n        float angle = atan(center.y, center.x);\n        float hexDist = cos(floor(0.5 + angle / 1.047) * 1.047 - angle) * dist;\n        bokeh = smoothstep(0.5, 0.4, hexDist);\n      }\n\n      // Soft glow falloff with enhanced bloom\n      float alpha = 1.0 - smoothstep(0.0, 0.5, dist);\n      alpha = pow(alpha, 1.2) * bokeh;\n\n      // Apply twinkling to brightness\n      alpha *= vBrightness * vTwinkle;\n\n      // Realistic star color based on temperature\n      vec3 color = temperatureToColor(vColorTemp);\n\n      // Chromatic aberration for bright close stars (lens effect)\n      if (vDistance < 80.0 && vBrightness > 0.7) {\n        float aberration = 0.02;\n        vec2 redOffset = center * (1.0 + aberration);\n        vec2 blueOffset = center * (1.0 - aberration);\n\n        float redDist = length(redOffset);\n        float blueDist = length(blueOffset);\n\n        vec3 aberratedColor;\n        aberratedColor.r = color.r * (1.0 - smoothstep(0.0, 0.5, redDist));\n        aberratedColor.g = color.g * (1.0 - smoothstep(0.0, 0.5, dist));\n        aberratedColor.b = color.b * (1.0 - smoothstep(0.0, 0.5, blueDist));\n\n        color = mix(color, aberratedColor, 0.3);\n      }\n\n      // Distance-based color shift (atmospheric perspective)\n      if (vDistance > 150.0) {\n        color = mix(color, vec3(0.8, 0.85, 1.0), 0.2);\n      }\n\n      gl_FragColor = vec4(color, alpha);\n    }\n  ")});function O({count:e=1e4,speed:t=2}){const n=l.useRef(),o=l.useRef(),r=l.useRef(),a=l.useRef(),{camera:i}=c(),[s,u,h,d,p]=l.useMemo(()=>{const t=new Float32Array(3*e),n=new Float32Array(e),o=new Float32Array(e),r=new Float32Array(e),a=new Float32Array(e);for(let s=0;s<e;s++){const e=3*s,l=100+200*Math.pow(Math.random(),.5),c=Math.random()*Math.PI*2,f=Math.acos(2*Math.random()-1);t[e]=i.position.x+l*Math.sin(f)*Math.cos(c),t[e+1]=i.position.y+l*Math.sin(f)*Math.sin(c),t[e+2]=i.position.z+l*Math.cos(f);const m=Math.random();n[s]=m<.7?1+1*Math.random():m<.95?2+2*Math.random():4+3*Math.random(),o[s]=.3+.7*Math.random();const u=Math.random();r[s]=u<.15?.3*Math.random():u<.8?.3+.36*Math.random():.66+.34*Math.random(),a[s]=Math.random()*Math.PI*2}return[t,n,o,r,a]},[e,i.position.x,i.position.y,i.position.z]),[v]=l.useMemo(()=>{const e=new Float32Array(1200),t=new Float32Array(200);for(let n=0;n<200;n++){const o=6*n,r=80*Math.random(),a=Math.random()*Math.PI*2,i=Math.cos(a)*r,s=80*(Math.random()-.5),l=-100*Math.random();e[o]=i,e[o+1]=s,e[o+2]=l;const c=5+10*Math.random();e[o+3]=i,e[o+4]=s,e[o+5]=l-c,t[n]=.2+.5*Math.random()}return[e,t]},[]);return f(s=>{if(!n.current)return;const l=new b;i.getWorldDirection(l);const c=l.clone().multiplyScalar(-t),f=n.current.geometry.attributes.position.array;for(let t=0;t<e;t++){const e=3*t;f[e]+=c.x,f[e+1]+=c.y,f[e+2]+=c.z;const n=f[e]-i.position.x,o=f[e+1]-i.position.y,r=f[e+2]-i.position.z,a=n*n+o*o+r*r,s=n*l.x+o*l.y+r*l.z;if(a>1e5||s<-50){const t=200+100*Math.random(),n=Math.random()*Math.PI*2,o=.0035,r=.75*Math.PI,a=Math.cos(r),s=Math.cos(o),c=a+Math.random()*(s-a),m=Math.acos(c),u=new b(0,1,0),h=(new b).crossVectors(l,u).normalize(),d=(new b).crossVectors(h,l).normalize(),p=t*Math.tan(m),v=p*Math.cos(n),g=p*Math.sin(n);f[e]=i.position.x+l.x*t+h.x*v+d.x*g,f[e+1]=i.position.y+l.y*t+h.y*v+d.y*g,f[e+2]=i.position.z+l.z*t+h.z*v+d.z*g}}if(n.current.geometry.attributes.position.needsUpdate=!0,o.current){const e=o.current.geometry.attributes.position.array,n=200,r=1.5*t;for(let o=0;o<n;o++){const n=6*o;e[n]+=c.x*(r/t),e[n+1]+=c.y*(r/t),e[n+2]+=c.z*(r/t),e[n+3]+=c.x*(r/t),e[n+4]+=c.y*(r/t),e[n+5]+=c.z*(r/t);const a=e[n]-i.position.x,s=e[n+1]-i.position.y,f=e[n+2]-i.position.z,m=a*a+s*s+f*f,u=a*l.x+s*l.y+f*l.z;if(m>5e4||u<-30){const t=120+30*Math.random(),o=Math.random()*Math.PI*2,r=60*Math.random(),a=new b(0,1,0),s=(new b).crossVectors(l,a).normalize(),c=(new b).crossVectors(s,l).normalize(),f=i.position.x+l.x*t+s.x*Math.cos(o)*r+c.x*Math.sin(o)*r,m=i.position.y+l.y*t+s.y*Math.cos(o)*r+c.y*Math.sin(o)*r,u=i.position.z+l.z*t+s.z*Math.cos(o)*r+c.z*Math.sin(o)*r;e[n]=f,e[n+1]=m,e[n+2]=u;const h=5+10*Math.random();e[n+3]=f+l.x*h,e[n+4]=m+l.y*h,e[n+5]=u+l.z*h}}o.current.geometry.attributes.position.needsUpdate=!0}r.current&&(r.current.time=s.clock.elapsedTime),a.current&&(a.current.time=s.clock.elapsedTime)}),m.jsxs("group",{children:[m.jsxs("points",{ref:n,children:[m.jsxs("bufferGeometry",{children:[m.jsx("bufferAttribute",{attach:"attributes-position",count:e,array:s,itemSize:3}),m.jsx("bufferAttribute",{attach:"attributes-size",count:e,array:u,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-brightness",count:e,array:h,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-colorTemp",count:e,array:d,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-twinklePhase",count:e,array:p,itemSize:1})]}),m.jsx("starfieldMaterial",{ref:r,transparent:!0,depthWrite:!1,blending:x,speed:t})]}),m.jsxs("lineSegments",{ref:o,children:[m.jsx("bufferGeometry",{children:m.jsx("bufferAttribute",{attach:"attributes-position",count:400,array:v,itemSize:3})}),m.jsx("lineBasicMaterial",{color:"#ffffff",transparent:!0,opacity:.3,blending:x,depthWrite:!1})]}),m.jsxs("mesh",{position:[0,0,-250],scale:[300,300,1],children:[m.jsx("planeGeometry",{args:[1,1,1,1]}),m.jsx("nebulaMaterial",{ref:a,transparent:!0,depthWrite:!1,blending:x,side:y})]})]})}s({NebulaMaterial:i({time:0,color1:new g(.05,0,.15),color2:new g(0,.1,.2),color3:new g(.15,0,.1)},"\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ","\n    uniform float time;\n    uniform vec3 color1;\n    uniform vec3 color2;\n    uniform vec3 color3;\n    varying vec2 vUv;\n\n    // Simple noise function\n    float noise(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n    }\n\n    float smoothNoise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n\n      float a = noise(i);\n      float b = noise(i + vec2(1.0, 0.0));\n      float c = noise(i + vec2(0.0, 1.0));\n      float d = noise(i + vec2(1.0, 1.0));\n\n      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    }\n\n    float fractalNoise(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      for (int i = 0; i < 4; i++) {\n        value += smoothNoise(p) * amplitude;\n        p *= 2.0;\n        amplitude *= 0.5;\n      }\n      return value;\n    }\n\n    void main() {\n      vec2 uv = vUv * 2.0 - 1.0;\n\n      // Multiple layers of noise moving at different speeds\n      float noise1 = fractalNoise(vUv * 3.0 + time * 0.02);\n      float noise2 = fractalNoise(vUv * 5.0 - time * 0.03);\n      float noise3 = fractalNoise(vUv * 7.0 + time * 0.01);\n\n      // Combine noise layers\n      float combinedNoise = (noise1 + noise2 + noise3) / 3.0;\n\n      // Create color variation\n      vec3 nebulaColor = mix(color1, color2, noise1);\n      nebulaColor = mix(nebulaColor, color3, noise2);\n\n      // Radial falloff from center for depth\n      float distFromCenter = length(uv);\n      float radialMask = 1.0 - smoothstep(0.0, 1.5, distFromCenter);\n\n      float alpha = combinedNoise * 0.15 * radialMask;\n\n      gl_FragColor = vec4(nebulaColor, alpha);\n    }\n  ")}),O.propTypes={count:z.number,speed:z.number};function I({text:e="HELLO",morphToText:t=null,scrollProgress:n=0,size:o=100,konamiActivated:r=!1,onMorphComplete:a=null}){const i=l.useRef(),s=l.useRef(),{viewport:u,mouse:h}=c(),d=l.useRef(Date.now()),p=l.useRef(!1),v=l.useRef(e),g=l.useRef(0),y=l.useRef(0),M=l.useRef(!1),A=l.useRef(new w(0,0)),T=l.useRef(0),[S,j]=l.useState(!1);l.useEffect(()=>{document.fonts.load("bold 100px Orbitron").then(()=>{j(!0)}).catch(()=>{setTimeout(()=>j(!0),1e3)})},[]);const C=(e,t,n,o)=>{n.fillStyle="#000000",n.fillRect(0,0,t.width,t.height),n.fillStyle="#ffffff",n.font=`bold ${o}px Orbitron, Arial`,n.textAlign="center",n.textBaseline="middle",n.fillText(e,t.width/2,t.height/2);const r=n.getImageData(0,0,t.width,t.height).data;let a=t.width,i=0,s=t.height,l=0;for(let h=0;h<t.width;h++)for(let e=0;e<t.height;e++){r[4*(e*t.width+h)]>128&&(a=Math.min(a,h),i=Math.max(i,h),s=Math.min(s,e),l=Math.max(l,e))}const c=(a+i)/2,f=(s+l)/2,m=i-a,u=[];for(let h=0;h<t.width;h+=1)for(let e=0;e<t.height;e+=1){if(r[4*(e*t.width+h)]>128){const t=.12,n=(h-c)*t,o=-(e-f)*t,r=Math.abs(n),a=m/2*t,i=Math.min(r/a,1),s=1.5*(1-i*i*i*.9),l=(Math.random()-.5)*s;u.push(n,o,l)}}return u},{positions:N,targetPositions:_,scrollTargetPositions:k,randomness:z,speeds:O,offsets:I,colorSeeds:R,particleCount:D}=l.useMemo(()=>{if(!S)return{positions:new Float32Array(0),targetPositions:new Float32Array(0),scrollTargetPositions:new Float32Array(0),randomness:new Float32Array(0),speeds:new Float32Array(0),offsets:new Float32Array(0),colorSeeds:new Float32Array(0),particleCount:0};const n=document.createElement("canvas"),r=n.getContext("2d");n.width=1024,n.height=256;const a=C(e,n,r,o),i=t?C(t,n,r,o):[...a],s=[],l=[],c=[],f=[],m=[],u=[],h=[];for(let e=0;e<a.length;e+=3){l.push(a[e],a[e+1],a[e+2]),i.length>e+2?c.push(i[e],i[e+1],i[e+2]):c.push(30*(Math.random()-.5),30*(Math.random()-.5),10*(Math.random()-.5));const t=Math.random()*Math.PI*2,n=20+30*Math.random(),o=Math.cos(t)*n,r=Math.sin(t)*n,d=20*(Math.random()-.5);s.push(o,r,d),f.push(Math.random()),m.push(.5+2*Math.random()),u.push(Math.random()*Math.PI*2),h.push(Math.random())}return{positions:new Float32Array(s),targetPositions:new Float32Array(l),scrollTargetPositions:new Float32Array(c),randomness:new Float32Array(f),speeds:new Float32Array(m),offsets:new Float32Array(u),colorSeeds:new Float32Array(h),particleCount:s.length/3}},[e,t,o,S]);return l.useEffect(()=>{if(S){if(v.current!==e){p.current=!1,d.current=Date.now()+500,v.current=e;const t=setTimeout(()=>{p.current=!0,d.current=Date.now()},500);return()=>clearTimeout(t)}{const e=setTimeout(()=>{p.current=!0,d.current=Date.now()},1e3);return()=>clearTimeout(e)}}},[e,S]),l.useEffect(()=>{r&&(g.current=Date.now(),setTimeout(()=>{y.current=Date.now()},2e3))},[r]),f(e=>{if(s.current){if(s.current.time=e.clock.elapsedTime,p.current){const e=(Date.now()-d.current)/3e3;s.current.morphProgress=Math.max(0,Math.min(e,1)),s.current.morphProgress>=1&&!M.current&&a&&(M.current=!0,a())}else s.current.morphProgress=0;if(s.current.scrollMorphProgress=n,g.current>0){const e=(Date.now()-g.current)/2e3;s.current.blackHoleEffect=e<1?e:e<2?2-e:0}else s.current.blackHoleEffect=0;if(y.current>0){const e=(Date.now()-y.current)/3e3;e<.5?s.current.explosionEffect=2*e:e<1?s.current.explosionEffect=2-2*e:(s.current.explosionEffect=0,e>1.2&&(g.current=0,y.current=0))}else s.current.explosionEffect=0;let t,o;if(i.current){const n=new P;n.setFromCamera(h,e.camera);const r=new b;i.current.getWorldPosition(r);const a=new b;e.camera.getWorldDirection(a);const s=(new E).setFromNormalAndCoplanarPoint(a,r),l=new b;n.ray.intersectPlane(s,l);const c=i.current.worldToLocal(l.clone());t=c.x,o=c.y}else t=h.x*(u.width/2),o=h.y*(u.height/2);const r=t-A.current.x,l=o-A.current.y,c=Math.sqrt(r*r+l*l);T.current=.9*T.current+.1*c,s.current.mousePosition.x=t,s.current.mousePosition.y=o,s.current.mouseVelocity=Math.min(T.current,5),A.current.set(t,o)}i.current&&(i.current.position.set(0,0,0),s.current&&s.current.morphProgress>.5&&(i.current.rotation.y=.05*Math.sin(.2*e.clock.elapsedTime),i.current.rotation.x=.02*Math.cos(.3*e.clock.elapsedTime)))}),0===D?null:m.jsxs("points",{ref:i,children:[m.jsxs("bufferGeometry",{children:[m.jsx("bufferAttribute",{attach:"attributes-position",count:D,array:N,itemSize:3}),m.jsx("bufferAttribute",{attach:"attributes-targetPosition",count:D,array:_,itemSize:3}),m.jsx("bufferAttribute",{attach:"attributes-scrollTargetPosition",count:D,array:k,itemSize:3}),m.jsx("bufferAttribute",{attach:"attributes-randomness",count:D,array:z,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-speed",count:D,array:O,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-offset",count:D,array:I,itemSize:1}),m.jsx("bufferAttribute",{attach:"attributes-colorSeed",count:D,array:R,itemSize:1})]}),m.jsx("fluidParticleMaterial",{ref:s,transparent:!0,depthWrite:!1,blending:x})]},e)}function R(){const e=l.useRef(null);return l.useEffect(()=>{const t=t=>{e.current&&(e.current.style.left=`${t.clientX}px`,e.current.style.top=`${t.clientY}px`)};return window.addEventListener("mousemove",t),()=>{window.removeEventListener("mousemove",t)}},[]),m.jsx("div",{ref:e,className:"simple-cursor"})}function D(e,t,n){const o=function(e,t,n={}){const o=(new Date).toISOString();return a({timestamp:o,level:e,message:t},n)}(e,t,n);return o}s({FluidParticleMaterial:i({time:0,morphProgress:0,scrollMorphProgress:0,mousePosition:new w(0,0),mouseVelocity:0,blackHoleEffect:0,explosionEffect:0,colorA:new g("#00ff88"),colorB:new g("#0088ff"),colorC:new g("#ff006e"),colorD:new g("#ffaa00"),colorE:new g("#aa00ff")},"\n    uniform float time;\n    uniform float morphProgress;\n    uniform float scrollMorphProgress;\n    uniform vec2 mousePosition;\n    uniform float mouseVelocity;\n    uniform float blackHoleEffect;\n    uniform float explosionEffect;\n\n    attribute vec3 targetPosition;\n    attribute vec3 scrollTargetPosition;  // Second text for scroll morph\n    attribute float randomness;\n    attribute float speed;\n    attribute float offset;\n    attribute float colorSeed;\n    \n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    void main() {\n      // Fluid physics simulation\n      float t = morphProgress;\n      vec3 pos = position;\n      \n      // Turbulence ONLY when forming (when t < 1.0), then completely stable\n      float turbulence = 0.0;\n      if (t < 1.0) {\n        turbulence = sin(time * 1.0 + offset * 6.28) * (1.0 - t) * (1.0 - t) * 1.5;\n        pos.x += sin(time * 0.5 + offset * 3.14) * turbulence;\n        pos.y += cos(time * 0.3 + offset * 2.0) * turbulence;\n        pos.z += sin(time * 0.7 + offset * 4.0) * turbulence * 0.5;\n      }\n      \n      // Morph to target position with elastic easing\n      float elasticT = t < 0.5\n        ? 4.0 * t * t * t\n        : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;\n\n      // First morph: random → name\n      vec3 baseTarget = mix(pos, targetPosition, elasticT);\n\n      // Second morph: name → tagline (scroll-based)\n      vec3 morphedPos = mix(baseTarget, scrollTargetPosition, scrollMorphProgress);\n      \n      // Black hole effect\n      if (blackHoleEffect > 0.0) {\n        vec3 blackHoleCenter = vec3(0.0, 0.0, 0.0);\n        vec3 toCenter = blackHoleCenter - morphedPos;\n        float distance = length(toCenter);\n        \n        // Spiral into black hole\n        float pullStrength = blackHoleEffect * (1.0 - smoothstep(0.0, 30.0, distance));\n        morphedPos += toCenter * pullStrength;\n        \n        // Add rotation for spiral effect\n        float angle = blackHoleEffect * 10.0 + distance * 0.5;\n        float cosAngle = cos(angle);\n        float sinAngle = sin(angle);\n        float x = morphedPos.x;\n        float z = morphedPos.z;\n        morphedPos.x = x * cosAngle - z * sinAngle;\n        morphedPos.z = x * sinAngle + z * cosAngle;\n      }\n      \n      // Supernova explosion effect with smooth transition\n      if (explosionEffect > 0.0) {\n        vec3 explosionCenter = vec3(0.0, 0.0, 0.0);\n        vec3 fromCenter = morphedPos - explosionCenter;\n        \n        // Smoother explosion curve\n        float smoothExplosion = smoothstep(0.0, 1.0, explosionEffect);\n        float explosionForce = smoothExplosion * 30.0 * (1.0 - smoothExplosion * 0.5);\n        morphedPos += normalize(fromCenter) * explosionForce;\n        \n        // Reduced randomness for smoother motion\n        morphedPos.x += sin(offset * 10.0) * smoothExplosion * 2.0;\n        morphedPos.y += cos(offset * 7.0) * smoothExplosion * 2.0;\n        morphedPos.z += sin(offset * 13.0) * smoothExplosion * 1.0;\n      }\n      \n      // Magnetic attraction to mouse (gentle, playful)\n      vec2 toMouse = mousePosition - vec2(morphedPos.x, morphedPos.y);\n      float mouseDistance = length(toMouse);\n      float attractionRadius = 6.0; // Sweet spot radius\n\n      if (mouseDistance < attractionRadius && mouseDistance > 0.1) {\n        // Gentle pull toward mouse, stronger when closer\n        float attractionStrength = (1.0 - mouseDistance / attractionRadius) * 0.3;\n\n        // TRAIL EFFECT - When mouse moves fast, add extra drag/momentum\n        float trailEffect = mouseVelocity * 0.8;\n        attractionStrength += trailEffect * (1.0 - mouseDistance / attractionRadius);\n\n        morphedPos.xy += normalize(toMouse) * attractionStrength * t; // Only when formed\n      }\n\n      // DEPTH/PARALLAX - Particles at different z-depths move differently with mouse\n      // Closer particles (negative z) move more, creating depth illusion\n      float depthFactor = (morphedPos.z + 1.0) * 0.5; // Normalize z to 0-1\n\n      vec2 parallaxOffset = mousePosition * 0.012 * (1.0 - depthFactor) * t; // Uniform parallax across all particles\n      morphedPos.xy += parallaxOffset;\n      \n      // DISABLE pulsing entirely for maximum stability\n      // float pulse = sin(time * 2.0 + offset * 10.0) * 0.008 * t;\n      // morphedPos *= 1.0 + pulse;\n      float pulse = 0.0;  // No pulsing at all\n\n      // QUANTUM FIELD EFFECT - Fluid hive mind oscillation when fully formed\n      if (t >= 1.0) {\n        // Slower, larger range for organic hive mind effect\n        float quantumFreq = time * 15.0 + offset * 50.0;  // Slower frequency\n        float quantumJitter = 0.12; // Larger range for fluid movement\n        morphedPos.x += sin(quantumFreq) * quantumJitter * randomness;\n        morphedPos.y += cos(quantumFreq * 1.3) * quantumJitter * randomness;\n        morphedPos.z += sin(quantumFreq * 0.7) * quantumJitter * randomness * 0.5;\n      }\n\n      // Set final position\n      vec4 mvPosition = modelViewMatrix * vec4(morphedPos, 1.0);\n      gl_Position = projectionMatrix * mvPosition;\n      \n      // Dynamic point size based on depth and morph state\n      float sizeBase = 3.0;\n      float depthSize = sizeBase * (300.0 / -mvPosition.z);\n      float morphSize = mix(2.0, depthSize, t);\n      \n      // Slightly increase size during effects (was 3.0, now 0.5)\n      float effectSize = 1.0 + max(blackHoleEffect, explosionEffect) * 0.5;\n      gl_PointSize = morphSize * (1.0 + pulse * 0.2) * effectSize;\n      \n      // Enhanced colors during effects\n      float effectBoost = max(blackHoleEffect, explosionEffect);\n      \n      // Gradient sweep across the text horizontally\n      float normalizedX = (targetPosition.x + 15.0) / 30.0;\n      float gradientPosition = normalizedX + time * 0.2 + effectBoost * 5.0; // Speed up during effects\n      \n      // Create smooth rainbow gradient across letters\n      vec3 color1 = vec3(0.0, 1.0, 0.53); // cyan\n      vec3 color2 = vec3(0.0, 0.53, 1.0); // blue\n      vec3 color3 = vec3(1.0, 0.0, 0.43); // magenta\n      vec3 color4 = vec3(1.0, 0.67, 0.0); // orange\n      vec3 color5 = vec3(0.67, 0.0, 1.0); // purple\n      \n      // Smooth gradient based on X position\n      float colorPhase = mod(gradientPosition * 2.0, 5.0);\n      \n      if (colorPhase < 1.0) {\n        vColor = mix(color1, color2, colorPhase);\n      } else if (colorPhase < 2.0) {\n        vColor = mix(color2, color3, colorPhase - 1.0);\n      } else if (colorPhase < 3.0) {\n        vColor = mix(color3, color4, colorPhase - 2.0);\n      } else if (colorPhase < 4.0) {\n        vColor = mix(color4, color5, colorPhase - 3.0);\n      } else {\n        vColor = mix(color5, color1, colorPhase - 4.0);\n      }\n      \n      // Subtle shimmer effect, enhanced during effects\n      vColor += vec3(0.1) * sin(time * 8.0 + normalizedX * 10.0) * t;\n      \n      // Make colors slightly more vibrant during effects\n      if (effectBoost > 0.0) {\n        vColor = mix(vColor, vec3(1.0, 0.5, 0.0), effectBoost * 0.2); // Subtle golden tint\n        vColor *= 1.0 + effectBoost * 0.3; // Much less brightness boost\n      }\n      \n      // Alpha based on morph progress - HIDE completely until morph starts\n      // When t < 0.05, alpha = 0 (invisible)\n      // When t >= 0.05, fade in smoothly\n      float fadeIn = smoothstep(0.0, 0.15, t);\n      vAlpha = mix(0.0, 0.3, fadeIn) * (0.8 + pulse * 0.1);\n      vAlpha = mix(vAlpha, 0.4, effectBoost * 0.5); // Much less brightness during effects\n    }\n  ","\n    varying vec3 vColor;\n    varying float vAlpha;\n    \n    void main() {\n      // Simple circular particle shape (no rays)\n      vec2 center = gl_PointCoord - vec2(0.5);\n      float dist = length(center);\n      \n      // No sparkle rays for cleaner look\n      float rays = 1.0;\n      \n      // Much sharper, smaller particles\n      float core = 1.0 - smoothstep(0.0, 0.2, dist);\n      float innerGlow = 1.0 - smoothstep(0.2, 0.4, dist);\n      \n      float alpha = core * 0.6 + innerGlow * 0.2;\n      alpha *= vAlpha;\n      \n      if (alpha < 0.01) discard;\n      \n      // Much less brightness and glow\n      vec3 finalColor = vColor;\n      finalColor = mix(finalColor, vec3(1.0), core * 0.1); // Minimal white\n      finalColor *= 1.0 + core * 0.2; // Very reduced brightness\n      \n      gl_FragColor = vec4(finalColor, alpha);\n    }\n  ")}),I.propTypes={text:z.string,morphToText:z.string,scrollProgress:z.number,size:z.number,konamiActivated:z.bool,onMorphComplete:z.func};const L={debug:(e,t={})=>D("DEBUG",e,t),info:(e,t={})=>D("INFO",e,t),warn:(e,t={})=>D("WARN",e,t),error:(e,t={})=>D("ERROR",e,t),performance:(e,t,n={})=>D("DEBUG",`Performance: ${e}`,a({duration:`${t.toFixed(2)}ms`},n)),component:(e,t,n={})=>D("DEBUG",`Component: ${e}`,a({event:t},n))};class F extends l.Component{constructor(e){super(e),this.state={hasError:!1,error:null,errorInfo:null}}static getDerivedStateFromError(e){return{hasError:!0,error:e}}componentDidCatch(e,t){L.error("React Error Boundary caught error",{error:e.toString(),errorMessage:e.message,errorStack:e.stack,componentStack:t.componentStack,timestamp:(new Date).toISOString()}),this.setState({errorInfo:t})}render(){return this.state.hasError?m.jsxs("div",{style:{display:"flex",flexDirection:"column",alignItems:"center",justifyContent:"center",minHeight:"100vh",padding:"2rem",textAlign:"center",backgroundColor:"#000",color:"#fff"},children:[m.jsx("h1",{style:{fontSize:"3rem",marginBottom:"1rem",color:"#ff006e"},children:"Something went wrong"}),m.jsx("p",{style:{fontSize:"1.2rem",marginBottom:"2rem",color:"#aaa"},children:"We're sorry for the inconvenience. Please refresh the page to try again."}),m.jsx("button",{onClick:()=>window.location.reload(),style:{padding:"1rem 2rem",fontSize:"1.1rem",backgroundColor:"#00ff88",color:"#000",border:"none",borderRadius:"8px",cursor:"pointer",fontWeight:"bold"},children:"Refresh Page"}),!1]}):this.props.children}}function B({id:e,children:t,fadeDelay:n=0,visible:o=!0}){const r=o&&n>0?`fade-in-${n}`:"";return m.jsx("div",{id:e,className:`content-section ${r}`,children:t})}F.propTypes={children:z.node.isRequired},B.propTypes={id:z.string.isRequired,children:z.node.isRequired,fadeDelay:z.number,visible:z.bool};const G=["ArrowUp","ArrowUp","ArrowDown","ArrowDown","ArrowLeft","ArrowRight","ArrowLeft","ArrowRight","b","a"];const H=3e4,U=1e4,V="Zachary Sluss",q=20,W={MOBILE_REGEX:/iPhone|iPad|iPod|Android/i,MAX_PIXEL_RATIO:2},X=5e3,$=100,Y={POSITION:[0,0,28],FOV:85},J={AMBIENT_INTENSITY:.02,AMBIENT_COLOR:"#1a1a2e",POINT_LIGHT_1:{position:[50,50,50],intensity:.1,color:"#4a5f8f"},POINT_LIGHT_2:{position:[-50,-50,-50],intensity:.08,color:"#2d3561"}},Z={ENABLE_ZOOM:!1,ENABLE_PAN:!1,ENABLE_ROTATE:!0,AUTO_ROTATE:!1,ENABLE_DAMPING:!0,DAMPING_FACTOR:.05,ROTATE_SPEED:.5,TARGET:[0,5,0]};function K(){return W.MOBILE_REGEX.test(navigator.userAgent)?U:H}const Q=l.lazy(()=>u(()=>import("./About-CtqTP-Ru.js"),__vite__mapDeps([0,1,2,3,4,5])).then(e=>({default:e.About}))),ee=l.lazy(()=>u(()=>import("./Skills-8PqVBMM8.js"),__vite__mapDeps([6,1,2,3,4,7])).then(e=>({default:e.Skills}))),te=l.lazy(()=>u(()=>import("./Experience-DGiQlRGT.js"),__vite__mapDeps([8,1,2,3,4,9])).then(e=>({default:e.Experience}))),ne=l.lazy(()=>u(()=>import("./Leadership-BX-IiNr-.js"),__vite__mapDeps([10,1,2,3,4,11])).then(e=>({default:e.Leadership}))),oe=l.lazy(()=>u(()=>import("./Contact-Bb81T8oE.js"),__vite__mapDeps([12,1,2,3,4,13])).then(e=>({default:e.Contact})));function re(){const{size:e,mouse:t}=c();return l.useEffect(()=>{const n=n=>{t.x=n.clientX/e.width*2-1,t.y=-n.clientY/e.height*2+1};return document.addEventListener("mousemove",n),()=>document.removeEventListener("mousemove",n)},[e,t]),null}function ae(){const[e,t]=l.useState(V),[n,o]=l.useState(!1),[r,a]=l.useState(!1),[i,s]=l.useState(!0);l.useEffect(()=>{const e=()=>{window.scrollY>$?s(!1):s(!0)};return window.addEventListener("scroll",e),()=>window.removeEventListener("scroll",e)},[]);const c=e=>{e.preventDefault();const t=e.currentTarget.getAttribute("href").substring(1),n=document.getElementById(t);n&&n.scrollIntoView({behavior:"smooth",block:"start"})};l.useEffect(()=>{let e=!1;const t=t=>{e||(e=!0,requestAnimationFrame(()=>{window.scrollBy(0,t.deltaY),e=!1}))};return window.addEventListener("wheel",t,{passive:!0}),()=>window.removeEventListener("wheel",t)},[]),function(e){const[t,n]=l.useState([]),o=l.useRef(e);l.useEffect(()=>{o.current=e},[e]),l.useEffect(()=>{const e=e=>{const t=1===e.key.length?e.key.toLowerCase():e.key;n(e=>{const n=[...e,t].slice(-10);return JSON.stringify(n)===JSON.stringify(G)?(o.current(),[]):n})};return window.addEventListener("keydown",e),()=>window.removeEventListener("keydown",e)},[])}(()=>{a(!0),setTimeout(()=>a(!1),X)});return m.jsxs(F,{children:[m.jsx(R,{}),m.jsxs(h,{className:"canvas",camera:{position:Y.POSITION,fov:Y.FOV},gl:{powerPreference:"high-performance",antialias:!1,stencil:!1,depth:!0,alpha:!1,pixelRatio:Math.min(window.devicePixelRatio,W.MAX_PIXEL_RATIO)},children:[m.jsx("color",{attach:"background",args:["#000000"]}),m.jsx("fog",{attach:"fog",args:["#000000",30,150]}),m.jsx("ambientLight",{intensity:J.AMBIENT_INTENSITY,color:J.AMBIENT_COLOR}),m.jsx("pointLight",{position:J.POINT_LIGHT_1.position,intensity:J.POINT_LIGHT_1.intensity,color:J.POINT_LIGHT_1.color}),m.jsx("pointLight",{position:J.POINT_LIGHT_2.position,intensity:J.POINT_LIGHT_2.intensity,color:J.POINT_LIGHT_2.color}),m.jsx(d,{enableZoom:Z.ENABLE_ZOOM,enablePan:Z.ENABLE_PAN,enableRotate:Z.ENABLE_ROTATE,autoRotate:Z.AUTO_ROTATE,enableDamping:Z.ENABLE_DAMPING,dampingFactor:Z.DAMPING_FACTOR,rotateSpeed:Z.ROTATE_SPEED,target:Z.TARGET}),m.jsx(re,{}),m.jsxs(l.Suspense,{fallback:null,children:[m.jsx(O,{count:K(),speed:2}),e&&m.jsx("group",{position:[0,5,0],children:m.jsx(I,{text:e.toUpperCase(),size:50,konamiActivated:r,onMorphComplete:()=>{o(!0)}},e)})]})]}),m.jsxs("div",{className:`scroll-indicator ${n&&i?"fade-in-1":""} ${i?"":"hide-scroll"}`,children:[m.jsx("div",{className:"mouse-icon",children:m.jsx("div",{className:"mouse-wheel"})}),m.jsx("p",{className:"scroll-text",children:"Scroll to explore"})]}),m.jsxs("div",{className:"top-right-overlay "+(n?"fade-in-1":""),children:[m.jsxs("div",{className:"portfolio-header",children:[m.jsx("h1",{className:"portfolio-title",children:"Zachary Sluss"}),m.jsx("p",{className:"portfolio-subtitle",children:"Welcome to my Portfolio!"})]}),m.jsxs("div",{className:"user-instructions",children:[m.jsx("p",{className:"instruction-item",children:"→ Drag to rotate view"}),m.jsx("p",{className:"instruction-item",children:"→ Scroll to explore content"}),m.jsx("p",{className:"instruction-item",children:"→ Hover over particles"})]}),m.jsxs("div",{className:"name-input-container",children:[m.jsx("input",{type:"text",className:"name-input",placeholder:"Enter your name",value:e,onChange:e=>{const n=(o=e.target.value)&&"string"==typeof o?o.replace(/[^\w\s-]/g,"").slice(0,q).trim():"";var o;t(n||V)},onKeyDown:e=>{"Enter"===e.key&&e.target.blur()},maxLength:q}),m.jsx("p",{className:"input-hint",children:"Type your name and press ENTER to see it form in particles"})]}),m.jsx("p",{className:"hint easter-egg-hint",children:"Secret Code: ↑↑↓↓←→←→BA"})]}),m.jsx("nav",{className:"sticky-nav "+(n?"fade-in-1":""),children:m.jsxs("div",{className:"nav-container",children:[m.jsx("a",{href:"#about",className:"nav-link",onClick:c,children:"About"}),m.jsx("a",{href:"#skills",className:"nav-link",onClick:c,children:"Skills"}),m.jsx("a",{href:"#experience",className:"nav-link",onClick:c,children:"Experience"}),m.jsx("a",{href:"#leadership",className:"nav-link",onClick:c,children:"Leadership"}),m.jsx("a",{href:"#passions",className:"nav-link",onClick:c,children:"Beyond the Enterprise"}),m.jsx("a",{href:"#contact",className:"nav-link",onClick:c,children:"Contact"})]})}),m.jsx("div",{className:"main-content",children:m.jsxs(l.Suspense,{fallback:m.jsx("div",{className:"section-loading",children:"Loading..."}),children:[m.jsx(B,{id:"about",fadeDelay:2,visible:n,children:m.jsx(Q,{})}),m.jsx(B,{id:"skills",fadeDelay:3,visible:n,children:m.jsx(ee,{})}),m.jsx(B,{id:"experience",fadeDelay:4,visible:n,children:m.jsx(te,{})}),m.jsx(B,{id:"leadership",fadeDelay:5,visible:n,children:m.jsx(ne,{})}),m.jsx(B,{id:"contact",fadeDelay:6,visible:n,children:m.jsx(oe,{})})]})})]})}p.createRoot(document.getElementById("root")).render(m.jsx(l.StrictMode,{children:m.jsx(ae,{})}));
